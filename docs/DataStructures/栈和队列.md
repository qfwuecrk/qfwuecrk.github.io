# 栈和队列

## 栈和队列的定义和特点

**栈**（stack）是限定仅在表尾进行插入和删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为**栈顶**（top），相应地，表头端称为**栈底**（bottom）。不含元素的空表称为**空栈**。栈又称为**后进先出**（Last In First Out，LIFO）的线性表。

**队列**是一种**先进先出**（First In First Out，FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一段称为**队尾**（rear），允许删除的一端则称为**队头**（front）。

## 栈的表示和操作的实现

### 顺序栈的表示和实现

**算法示例**

- 顺序栈的初始化
```c
#define OK 1
#define ERROR 0
#define OVERFLOW -2
#define MAXSIZE 1000

typedef int Status;

typedef struct stack
{
	int* bottom;
	int* top;
	int stack_size;
}Sqstack;

/* 顺序栈初始化 */
Status InitStack(Sqstack* stack)
{
	stack->bottom = malloc(sizeof(int) * MAXSIZE);
	if (stack->bottom == NULL)
	{
		return ERROR;
	}
	stack->top = stack->bottom;
	stack->stack_size = MAXSIZE;
	return OK;
}
```

- 顺序栈的入栈
```c
/* 顺序栈入栈 */
Status Push(Sqstack* stack, int e)
{
	if (stack->top - stack->bottom == stack->stack_size)
	{
		return ERROR;
	}

	*(stack->top) = e; // 先赋值
	stack->top += 1; // 再++

	return OK;
}
```

- 顺序栈的出栈
```c
/* 顺序栈出栈 */
Status Pop(Sqstack* stack, int* e)
{
	if (stack->top == stack->bottom)
	{
		return ERROR;
	}

	stack->top -= 1; // 先--
	*e = *(stack->top); // 再赋值

	return OK;
}
```

### 链栈的表示和实现

**算法示例**

- 链栈的初始化
```c
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;

typedef struct StackNode
{
	int data;
	struct StackNode* next;
}StackNode, * LinkStack;

/* 链栈初始化 */
Status InitStack(LinkStack* stack)
{
	*stack = NULL;
	return OK;
}
```

- 链栈的入栈
```c
/* 链栈的入栈 */
Status Push(LinkStack* stack, int e)
{
	StackNode* node = malloc(sizeof(StackNode));
	node->data = e;
	node->next = (*stack);

	*stack = node;

	return OK;
}
```

- 链栈的出栈
```c
/* 链栈的出栈 */
Status Pop(LinkStack* stack, int* e)
{
	if ((*stack) == NULL)
	{
		return ERROR;
	}

	StackNode* node = *stack;
	*e = node->data;

	*stack = node->next;
	free(node);

	return OK;
}
```

## 栈与递归

**算法示例**

- 遍历输出链表中各个节点的递归算法
```c
void TraverseList(LinkList p)
{
	if (p == NULL)
	{
		return;
	}
	printf("%d\n", p->data);
	TraverseList(p->next);
}
```

- Hanoi塔问题的递归算法
```c
/* A -> C, 经过B */
void Hanoi(int n, char A, char B, char C)
{
	if (n == 1)
	{
		printf("%c -> %c\n", A, C);
		return;
	}

	Hanoi(n - 1, A, C, B);
	printf("%c -> %c\n", A, C);
	Hanoi(n - 1, B, A, C);
}
```

### 递归算法的效率分析

- 时间复杂度分析
- 空间复杂度分析

## 队列的表示和操作实现

### 队列的类型定义

### 循环队列 - 队列的顺序表示和实现

**算法示例**

- 循环队列的初始化
- 求循环队列的长度
- 循环队列的入队
- 循环队列的出队
- 取循环队列的队头元素

### 链队 - 队列的链式表示和实现

**算法示例**

- 链队的初始化
- 链队的入队
- 链队的出队
- 取链队的队头元素

## 案例分析与实现

**算法示例**

- 数制的转换
- 括号的匹配
- 表达式求值
- 舞伴问题